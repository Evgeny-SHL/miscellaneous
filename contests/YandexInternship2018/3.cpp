/*

Автодополнение

Аркадий реализовал интерактивную систему автодополнения, которая должна позволить ему быстрее набирать тексты университетских работ, в том числе и дипломной.

Система запоминает все слова, которые уже есть в тексте. Если Аркадий набирает очередное слово, введенная непустая часть которого совпадает с префиксом ровно одного из уже введенных слов, то после нажатия специальной комбинации клавиш введенную часть можно мгновенно дополнить имеющимся словом.

Например, Аркадий уже ввел слова дипломная работа и автодополнение в различных системах. Рассмотрим несколько вариантов очередного слова, которое ему нужно ввести:

диплом — после ввода первого символа система предложит принять автодополнение дипломная, но оно не подходит;
работа — после ввода первого и второго символа система не будет ничего предлагать, т.к. есть два различных слова в тексте, которые начинаются с текущего префикса, но после ввода третьего символа останется только одно слово (предложенное автодополнение следует принять);
различие — вновь вариант с автодополнением появится только после ввода третьего символа, но в этот раз принимать предложенный вариант не следует.
У Аркадия не работает клавиша удаления введенных символов, поэтому удалять символы из текста он не может.

Аркадий также решил, что не будет использовать автодополнение, если предлагаемое слово является началом набираемого, но не совпадает с ним целиком.

Помогите Аркадию определить, сколько раз он воспользуется функцией автодополнения, если хочет максимально уменьшить количество нажатий на клавиши клавиатуры, соответствующие буквенным символам.

Формат ввода
В первой строке входных данных записано одно целое число n (1 ≤ n ≤ 100 000) — количество слов, которые собирается набрать Аркадий. Во второй строке записаны n слов si (1 ≤ |si| ≤ 1000). Все слова в строке состоят только из строчных букв английского алфавита и разделены одиночными пробелами.

Суммарная длина всех слов не превосходит 1 000 000 символов.

Формат вывода
В единственной строке выведите одно целое число: количество нажатий буквенных клавиш на клавиатуре.

*/

#include <array>
#include <memory>
#include <iostream>

class Node {
 public:
  Node( char letter, bool isTerminal ) :
      Letter( letter ), IsTerminal( isTerminal ), Count( 0 )
  {
  }

  void Add( const std::string& word )
  {
    auto current = this;
    for( auto letter : word ) {
      if( current->Nexts[letter - 'a'] == nullptr ) {
        current->Nexts[letter - 'a'] = std::make_unique<Node>( letter, false );
      }
      ++(current->Count);
      current = current->Nexts[letter - 'a'].get();
    }
    ++(current->Count);
    current->IsTerminal = true;
  }

  char Letter;
  bool IsTerminal{false};
  int Count{0};
  std::array<std::unique_ptr<Node>, 26> Nexts{};
};

int main() {
  int wordsCount = 0;
  std::cin >> wordsCount;

  int total = 0;
  std::string word;

  std::unique_ptr<Node> trie{ new Node('\0', false) };

  for( int wordId = 0; wordId < wordsCount; ++wordId) {
    std::cin >> word;
    auto current = trie.get();
    for( int i = 0; i < word.length(); ++i ) {
      char letter = word[i];
      ++total;
      current = current->Nexts[letter - 'a'].get();
      if( current == nullptr ) {
        total += word.length() - i - 1;
        trie->Add(word);
        break;
      } else if ( current->Count != 1 ) {
        continue;
      } else {
        auto next = current;
        auto found = true;
        for( int j = i + 1; j < word.length(); ++j ) {
          char nextLetter = word[j];
          next = next->Nexts[nextLetter - 'a'].get();
          if( next == nullptr ) {
            found = false;
            break;
          }
        }
        if( !found || next->IsTerminal == false ) {
          total += word.length() - i - 1;
          trie->Add(word);
        }
        break;
      }
    }
  }

  std::cout << total << std::endl;

  return 0;
}

