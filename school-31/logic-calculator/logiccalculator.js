'use strict';

var
	submit = document.getElementById('submit'),					// форма для отправки данных,
	ops = {														// перечень логических операций,
		'¬': {
			sign: '¬',
			name: 'Инверсия',
			func: function(x) { return +(!x) },
			order: 0,
			unary: true
		},
		'↑': {
			sign: '↑',
			name: 'Штрих Шеффера',
			func: function(x,y) { return +(!(x && y)) },
			order: 1,
			unary: false
		},
		'↓': {
			sign: '↓',
			name: 'Стрелка Пирса',
			func: function(x,y) { return +(!(x || y)) },
			order: 1,
			unary: false
		},
		'∧': {
			sign: '∧',
			name: 'Конъюнкция',
			func: function(x,y) { return +(x && y) },
			order: 2,
			unary: false
		},
		'∨': {
			sign: '∨',
			name: 'Дизъюнкция',
			func: function(x,y) { return +(x || y) },
			order: 3,
			unary: false
		},
		'⊕': {
			sign: '⊕',
			name: 'Неравнозначность',
			func: function(x,y) { return +(!(x == y)) },
			order: 3,
			unary: false
		},
		'→': {
			sign: '→',
			name: 'Импликация',
			func: function(x,y) { return +(!x || y) },
			order: 4,
			unary: false
		},
		'←': {
			sign: '←',
			name: 'Обратная импликация',
			func: function(x,y) { return +(!y || x) },
			order: 4,
			unary: false
		},
		'↛': {
			sign: '↛',
			name: 'Инверсия импликации',
			func: function(x,y) { return +(x && !y) },
			order: 4,
			unary: false
		},
		'↚': {
			sign: '↚',
			name: 'Инверсия обратной импликации',
			func: function(x,y) { return +(y && !x) },
			order: 4,
			unary: false
		},
		'↔': {
			sign: '↔',
			name: 'Эквиваленция',
			func: function(x,y) { return +(x == y) },
			order: 5,
			unary: false
		}
	},
	varSymbols = 'abcdefghijklmnopqrstuvwxyz',					// допустимые символы для переменных,
	consts = '01',												// допустимые символы для констант,
	opSymbols = '¬↑↓∧∨⊕→←↛↚↔~!/\\&*|+^><-%=';						// символы для логическиъ операций.
	ops['~'] = ops['¬'];										// Определяем дополнительные символы для операций.
	ops['!'] = ops['¬'];
	ops['/'] = ops['↑'];
	ops['\\'] = ops['↓'];
	ops['&'] = ops['∧'];
	ops['*'] = ops['∧'];
	ops['|'] = ops['∨'];
	ops['+'] = ops['∨'];
	ops['^'] = ops['⊕'];
	ops['>'] = ops['→'];
	ops['<'] = ops['←'];
	ops['-'] = ops['↛'];
	ops['%'] = ops['↚'];
	ops['='] = ops['↔'];

function countValue(f, code, vars) {				// Функция вычисления значения формулы.

	var p = [],										// Массив формул и
		q = [];										// массив операций формулы.

	for (var i = 0; i < f.length; i++) {			// Посимвольно обрабатываем формулу.
		var c = f.charAt(i);						// Получаем символ формулы.

		if (varSymbols.indexOf(c) != -1) p.push(c);			// Если он в списке символов для переменных, то бавляем переменную в массив формулы.
		else if (c == '(') {						// Если это открывающая скобка, то
			var n = i,								// запоминаем номер символа формулы,
				s = 1,								// создаем счетчик скобок и
				m = n+1;							// получаем номер следующего символа формулы.

				while (s != 0) {						// Пока счетчик скобок не нулевой,
					if (f.charAt(m) == '(') s++;		// то если скобка открывающая, увеличиваем его,
					else if (f.charAt(m) == ')') s--;	// а если закрывающая, то уменьшаем.
					m++;								// Переходим к следующему символу.
				}

			i = m-1;												// Возвращаемся на символ назад.
			p.push(countValue(f.slice(n+1, m-1),code,vars));		// Вычисляем значение выражения в скобках и записываем его в массив формул.
		} else if (consts.indexOf(c) != -1) p.push(+c);				// Если символ — константа, то дабавляем его в массив формул, преобразовав к числу.
		else if (opSymbols.indexOf(c) != -1) {						// Если символ обозначает логическую операцию,
			q.push( { n: p.length-1, m: p.length, oper: ops[c] } )	// то добавляем в массив операций объект, хранящий индексы операндов и саму операцию,
			if (ops[c].unary) q[q.length-1].n++;					// но если это инверсия, то мы увеличиваем индекс левого операнда из-за унарности отрицания.
		}
	}

	for (var i = 0; i < p.length; i++)											// Преобразуем значения формул в массиве формул к числам,
		if (typeof p[i] == 'string') p[i] = +code.charAt(vars.indexOf(p[i]));	// если они — строки (могут быть константы или уже вычисленные выражения в скобках).

	while (q.length > 0) {							// Пока массив операций формулы не пустой,
		for (var i = 0; i <= 5; i++) {				// проходимся по приоритету операций.
			var j = 0;								// Пока индекс операции из массива.
			while (j < q.length) {					// меньше длины массива,
				if (q[j].oper.order != i) {			// то если приоритет операции не искомый,
					j++;							// то перезодим к следующей операции.
					continue
				}

				var g,														// В другом случае создаем переменную вычисленного значения
					oper = q[j].oper;										// и получаем нужную операцию.
				if (!oper.unary) g = oper.func(p[q[j].n], p[q[j].m]);		// Если это не инверсия, то вычислить значение, обратившись к двум операндам,
				else g = oper.func(p[q[j].n]);								// иначе к одному.
				p[q[j].n] = g,												// В любом случае и левой, и правой формуле
				p[q[j].m] = g;												// из массива присваиваем вычисленные значения.
				if (!oper.unary) {											// Если операция была не инверсия,
					p.splice(q[j].n,1);										// то удаляем левый операнд из массива формул
					for (var k = 0; k < q.length; k++) {					// и сдвигаем все индексы в массивах операций, идущих за удаленным операндом.
						if (q[k].n > q[j].n) q[k].n--;
						if (q[k].m > q[j].n) q[k].m--;
					}
				}
				q.splice(j,1);						// Удаляем операцию из массива операций.
			}
		}
	}

	return p[0];									// Возвращаем единственное значение из массива формул — итоговое значение формулы.
}

function checkFormula(f, e) {						// Функция проверки формулы.
	if (!f)											// Проверка на пустоту.
		return { valid: false, error: 'Пустая формула.' };

	if ((opSymbols.indexOf(f.charAt(0)) != -1) && (f.charAt(0) != '¬'))		// Проверка на первый символ.
		return { valid: false, error: 'Неверная расстановка формул, логических операций и скобок: первый символ не может быть операцией не отрицания.' };

	var k = 0,										// Счетчик скобок.
		p = varSymbols,								// Множества символов: переменные,
		o = opSymbols,								// все операции,
		con = consts,								// константы,
		notnot = '↑↓∧∨⊕→←↔';						// все операции, кроме отрицания.

	for (var i = 0; i < f.length; i++) {			// Проходимся по формуле.
		var c = f.charAt(i);						// Получаем текущий символ.
		if ((varSymbols.indexOf(c) == -1) && (consts.indexOf(c) == -1) && (opSymbols.indexOf(c) == -1) && ('()'.indexOf(c) == -1))	// Проверка на допустимость.
			return { valid: false, error: 'Недопустимый символ: «' + c + '».' };

		if (c == '(') k++;
		else if (c == ')') k--;

		if (k < 0)									// Если в какой-то момент он оказался отрицательный, то существует ошибка.
			return { valid: false, error: 'Неправильная скобочная последовательность.' };

		if (i < f.length-1) {						// Просмотр пар символов формулы на наличие недопустимых конмбинаций.
			var c1 = f.charAt(i+1);					// Получаем второй символ.

			if ((p.indexOf(c) != -1) && (p.indexOf(c1) != -1))
				return { valid: false, error: 'Неверная расстановка формул, логических операций и скобок: конструкция «переменная — «переменная».' };
			if ((p.indexOf(c) != -1) && (c1 == '('))
				return { valid: false, error: 'Неверная расстановка формул, логических операций и скобок: конструкция «переменная — открывающая скобка».' };
			if ((p.indexOf(c) != -1) && (c1 == '¬'))
				return { valid: false, error: 'Неверная расстановка формул, логических операций и скобок: конструкция «переменная — операция отрицания».' };
			if ((p.indexOf(c) != -1) && (con.indexOf(c1) != -1))
				return { valid: false, error: 'Неверная расстановка формул, логических операций и скобок: конструкция «переменная — константа».' };
			if ((c == '(') && (c1 == ')'))
				return { valid: false, error: 'Неверная расстановка формул, логических операций и скобок: конструкция «открывающая скобка — закрывающая скобка».' };
			if ((c == '(') && (notnot.indexOf(c1) != -1))
				return { valid: false, error: 'Неверная расстановка формул, логических операций и скобок: конструкция «открывающая скобка — операция не отрицания».' };
			if ((c == ')') && (p.indexOf(c1) != -1))
				return { valid: false, error: 'Неверная расстановка формул, логических операций и скобок: конструкция «закрывающая скобка — «переменная».' };
			if ((c == ')') && (c1 == '('))
				return { valid: false, error: 'Неверная расстановка формул, логических операций и скобок: конструкция «закрывающая скобка — открывающая скобка».' };
			if ((c == ')') && (c1 == '¬'))
				return { valid: false, error: 'Неверная расстановка формул, логических операций и скобок: конструкция «закрывающая скобка — операция отрицания».' };
			if ((c == ')') && (con.indexOf(c1) != -1))
				return { valid: false, error: 'Неверная расстановка формул, логических операций и скобок: конструкция «закрывающая скобка — константа».' };
			if ((o.indexOf(c) != -1) && (c1 == ')'))
				return { valid: false, error: 'Неверная расстановка формул, логических операций и скобок: конструкция «операция — закрывающая скобка».' };
			if ((o.indexOf(c) != -1) && (notnot.indexOf(c1) != -1))
				return { valid: false, error: 'Неверная расстановка формул, логических операций и скобок: конструкция «операция — операция не отрицания».' };
			if ((con.indexOf(c) != -1) && (p.indexOf(c1) != -1))
				return { valid: false, error: 'Неверная расстановка формул, логических операций и скобок: конструкция «константа — «переменная».' };
			if ((con.indexOf(c) != -1) && (c1 == '('))
				return { valid: false, error: 'Неверная расстановка формул, логических операций и скобок: конструкция «константа — открывающая скобка».' };
			if ((con.indexOf(c) != -1) && (c1 == '¬'))
				return { valid: false, error: 'Неверная расстановка формул, логических операций и скобок: конструкция «константа — операция отрицания».' };
			if ((con.indexOf(c) != -1) && (con.indexOf(c1) != -1))
				return { valid: false, error: 'Неверная расстановка формул, логических операций и скобок: конструкция «константа — константа».' };
		}
	}

	if (k)											// Если счетчик скобок не нулевой, то существует ошибка.
		return { valid: false, error: 'Неправильная скобочная последовательность.' };
	if (opSymbols.indexOf(c) != -1)					// Если последний символ формулы — операция, то существует ошибка.
		return { valid: false, error: 'Неверная расстановка формул, логических операций и скобок: последний символ не может быть логической операцией.' }

	return { valid: true, error: '' };				// Добрились до конца, формула корректна.
}

function standartFormula(f) {						// Функция приведения формулы к стандартному виду.
	var g = '';	
	f = f + ' ';									// Новая формула.

	for (var i = 0; i < f.length-1; i++) {											// Проходимся по символам.
		if (f.charAt(i) == ' ') continue;											// Если пробел, то ничего не делаем;
		if (opSymbols.indexOf(f.charAt(i)) != -1) g = g + ops[f.charAt(i)].sign;	// если символ операции, то меняем на стандартный;
		else {
			g = g + f.charAt(i).toLowerCase();
			if (varSymbols.indexOf(f.charAt(i)) != -1 &&  varSymbols.indexOf(f.charAt(i+1)) != -1 ||
				varSymbols.indexOf(f.charAt(i)) != -1 && f.charAt(i+1) == '(' ||
				varSymbols.indexOf(f.charAt(i)) != -1 && '¬~!'.indexOf(f.charAt(i+1)) != -1 ||
				f.charAt(i) == ')' &&  varSymbols.indexOf(f.charAt(i+1)) != -1 ||
				f.charAt(i) == ')' && f.charAt(i+1) == '(' ||
				f.charAt(i) == ')' && '¬~!'.indexOf(f.charAt(i+1)) != -1) g = g + '∧';										// если другой символ, то оставляем его в нижнем регистре.
		}
	}

//	getWriteForm(g);
	return g;										// Возвращаем новую формулу.
}

/*function getWriteForm(f) {
	var g = '';

	for (var i = 0; i < f.length; i++) {
		var c = f.charAt(i);

		if ('∧&*'.indexOf(c) != -1) continue;
		if ('¬~!'.indexOf(c) != -1) {
			var k = 0;
			var t = false;
			for (var j = i+1; j < f.length; j++) {
				var d = f.charAt(j);

				if (d == '(') {
					k++;
					t = true;
				}
				if (d == ')') k--;
				if (k >= 0) {
					if (d == '(' && t) continue;
					if (d == ')' && t) break;
					g = g + d + '\u033F';
				} else break;
			}
			i = j+1;
		}
		g = g + f.charAt(i);
	}

	console.log(g);
}*/

function difficult(f) {
	var
		d = 0,
		k = 0;
	for (var i = 0; i < f.length; i++) {
		var c = f.charAt(i);
		if (varSymbols.indexOf(c) != -1) d++;
		if (opSymbols.indexOf(c) != -1) d++;
		if (c == '¬') d++;
		if (c == '(') {
			k++;
			d += k;
		}
		if (c == ')') k--;
	}

	return d;
}